# AUTOGENERATED! DO NOT EDIT! File to edit: 03_perspective_transform.ipynb (unless otherwise specified).

__all__ = ['normalized', 'vector_tile', 'trim_image', 'fit_line']

# Cell
import numpy as np
import matplotlib.pyplot as plt

def normalized(a, axis=-1, order=2):
    l2 = np.atleast_1d(np.linalg.norm(a, order, axis))
    l2[l2==0] = 1
    return a / np.expand_dims(l2, axis)

def vector_tile(mean_flow, xrange, yrange, tilesize = None):
    # Tilesize = pixels along an edge of the vector grid

    surfzone_flow = mean_flow[yrange[0]:yrange[1], xrange[0]:xrange[1]]

    if tilesize is None:
        if surfzone_flow.shape[0] < surfzone_flow.shape[1]//3:
            tilesize = surfzone_flow.shape[0]
        else:
            tilesize = surfzone_flow.shape[1]//3

    n_tiles_xdir = surfzone_flow.shape[1]//tilesize
    n_tiles_ydir = surfzone_flow.shape[0]//tilesize

    raw_vector_grid = np.zeros((n_tiles_ydir, n_tiles_xdir, 2))
    vector_grid = np.zeros((n_tiles_ydir, n_tiles_xdir, 3))

    plt.figure(figsize=(15,5))
    for xi in range(n_tiles_xdir):
        for yi in range(n_tiles_ydir):
            vector_grid[yi, xi, :2] = surfzone_flow[tilesize*yi:tilesize*(yi+1),
                                                    tilesize*xi:tilesize*(xi+1)].mean(axis=0).mean(axis=0)
            # Magnitude of the mean vector
            vector_grid[yi, xi, 2]  = np.sqrt(vector_grid[yi, xi, 0]*vector_grid[yi, xi, 0] +
                                              vector_grid[yi, xi, 1]*vector_grid[yi, xi, 1])
            # Direction of the normalized mean of the x and y vector components
            vector_grid[yi, xi, :2] = normalized(vector_grid[yi, xi, :2])

    max_magnitude = vector_grid[:,:,2].max()
    for xi in range(n_tiles_xdir):
        for yi in range(n_tiles_ydir):
            vector_grid[yi, xi, 2] = vector_grid[yi, xi, 2] / max_magnitude
            plt.arrow(xi, yi, 0.6*vector_grid[yi, xi, 0], 0.6*vector_grid[yi, xi, 1],
                      color='k', width=.07, alpha=vector_grid[yi, xi, 2])


    plt.imshow(vector_grid[:,:,2])
    plt.show()

    return vector_grid

# Cell
def trim_image(image, xrange, yrange):
    return image[yrange[0]:yrange[1], xrange[0]:xrange[1]]

# Cell
def fit_line(heatmap, plot=False):

    high_indicies = np.where(heatmap > heatmap.mean())

    high_idx_array = np.dstack(high_indicies)[0][:,::-1]

    # https://docs.opencv.org/2.4/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html?highlight=fitline#fitline
    line_def = cv2.fitLine(high_idx_array, 1, 0, 1, 0.1)
    # Y is down, X is to right in image space
    vx, vy, x0, y0 = line_def

    line_half_length = heatmap.shape[1]/3
    x1 = x0 - vx*line_half_length
    y1 = y0 - vy*line_half_length
    x2 = x0 + vx*line_half_length
    y2 = y0 + vy*line_half_length
    end_points = ((x1,y1), (x2,y2))

    if plot:
        img = cv2.line(heatmap.copy(), (x1, y1), (x2, y2), .5, thickness=8)
        plt.imshow(img, )

    return line_def, end_points
