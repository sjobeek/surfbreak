# AUTOGENERATED! DO NOT EDIT! File to edit: 02_wave_detection.ipynb (unless otherwise specified).

__all__ = ['dense_optical_flow', 'heatmap_fit', 'trim_image', 'avg_wave_flows', 'fit_mean_flows',
           'get_sample_start_times', 'detect_surfzone']

# Cell
import numpy as np
import cv2

def dense_optical_flow(image_cube, start_idx=0, n_flows=None, step_size=1):
    """xy flow:  Y is down, X is to right in image space
       hsv flow: hue/saturation encode direction, value (magnitude) is in index 2"""
    if n_flows is None:
        n_flows = (image_cube.shape[-1] // step_size) - 1

    prv_img = image_cube[:,:,start_idx]
    hsv = np.zeros((prv_img.shape[0], prv_img.shape[1], 3), dtype='float32')
    hsv[...,1] = 255
    flows = []
    hsv_flows = []
    for i in range(n_flows-1):
        next_img = image_cube[:,:,step_size*(i+1) + start_idx]
        flow = cv2.calcOpticalFlowFarneback(prv_img,next_img, None, 0.5, 3, 15, 3, 5, 1.2, 0)
        flows.append(flow)

        mag, ang = cv2.cartToPolar(flow[...,0], flow[...,1])
        hsv[...,0] = ang*180/np.pi/2
        hsv[...,2] = mag # cv2.normalize(mag,None,0,255,cv2.NORM_MINMAX)
        rgb = cv2.cvtColor(hsv,cv2.COLOR_HSV2RGB)
        hsv_flows.append(rgb)

        prv_img = next_img

    xy_flow_cube = np.stack(flows, axis=3)
    hsv_flow_cube = np.stack(hsv_flows, axis=3)
    return xy_flow_cube, hsv_flow_cube


# Cell
def heatmap_fit(input_heatmap, draw_fit=False):
    """Returns (xrange, yrange) of the best fit to given heatmap"""

    frame = input_heatmap

    # setup initial location of window (top-left corner, plus x and y offsets)
    # X is left-to-right, Y is top-to-bottom
    x, y, w, h = 0, 0, frame.shape[1], frame.shape[0] # simply hardcoded the values
    track_window = (x, y, w, h)

    # Setup the termination criteria, either 10 iteration or move by atleast 1 pt
    term_crit = ( cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 30, 1 )

    # Define the target heatmap
    prob_image = frame

    # apply camshift to get the new location
    ret, track_window = cv2.CamShift(prob_image, track_window, term_crit)

    if draw_fit:
        import matplotlib.pyplot as plt
        # Draw it on image
        pts = cv2.boxPoints(ret)
        pts = np.int0(pts)
        img2 = cv2.polylines(frame.copy(),[pts],True, 1,2)
        plt.figure(figsize=(10,5))
        plt.imshow(img2)
        plt.show()

    max_x = max(p[0] for p in pts)
    min_x = max(0, min(p[0] for p in pts))
    max_y = max(p[1] for p in pts)
    min_y = min(p[1] for p in pts)

    return (min_x, max_x), (min_y, max_y)

# Cell
def trim_image(image, xrange, yrange):
    return image[yrange[0]:yrange[1], xrange[0]:xrange[1]]

# Cell
from surfbreak import load_videos
import matplotlib.pyplot as plt
import numpy as np
import cv2
import dask

@dask.delayed
def avg_wave_flows(video_file, start_s, duration_s=1):
    """Detects the region of the image which contains breaking waves.
    Returns a 2-tuple (mean_flow_x, mean_flow_y):
        mean_flow_mag: a dense estimate of the average optical flow across the input image
        xrange: x range of detected waves
        yrange: y range of detected waves"""

    frames = load_videos.decode_frame_sequence(video_file, duration_s=duration_s, start_s=start_s, RGB=True,
                                                  one_image_per_n_frames=2)

    greyscale_cube = np.dstack(tuple(cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) for img in frames))

    xy_cube, hsv_cube = dense_optical_flow(greyscale_cube, start_idx=0, n_flows=None, step_size=1)

    return xy_cube.mean(axis=3)

@dask.delayed
def fit_mean_flows(avg_flows, draw_fit=False):
    mean_flow = np.stack(avg_flows,axis=3).mean(axis=3)
    mean_flow_mag = np.sqrt(mean_flow[:,:,0]*mean_flow[:,:,0] + mean_flow[:,:,1]*mean_flow[:,:,1])

    xrange, yrange = heatmap_fit(mean_flow_mag, draw_fit=draw_fit)
    return mean_flow, xrange, yrange


# Cell
def get_sample_start_times(video_file, n_samples=10):
    """Returns N equally spaced video start times in seconds"""
    video_length_s = load_videos.video_length_s(video_file)
    sample_spacing = int((video_length_s - 1) / n_samples)
    start_times_s = [sample_spacing * i for i in range(n_samples)]
    return start_times_s

def detect_surfzone(video_file, n_samples=10, processes=4, draw_fit=False, scheduler='threads'):
    """Detects the region of the image which contains breaking waves, using cached graph
        Returns a 3-tuple (mean_flow_xy, xrange, yrange):"""
    start_times = get_sample_start_times(video_file, n_samples=n_samples)
    print("Video subsample start times (seconds):", start_times)
    average_flows = [avg_wave_flows(video_file, start_s=st, duration_s=1)
                     for st in start_times]
    return fit_mean_flows(average_flows, draw_fit=True)