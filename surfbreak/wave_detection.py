# AUTOGENERATED! DO NOT EDIT! File to edit: 03_wave_detection.ipynb (unless otherwise specified).

__all__ = ['dense_optical_flow', 'heatmap_fit', 'trim_image']

# Cell
import numpy as np
import cv2

def dense_optical_flow(image_cube, start_idx=0, n_flows=None, step_size=1):
    """xy flow:  X is down, Y is to right in image space
       hsv flow: hue/saturation encode direction, value (magnitude) is in index 2"""

    if n_flows is None:
        n_flows = (image_cube.shape[-1] - 1) // step_size

    prv_img = image_cube[:,:,start_idx]
    hsv = np.zeros((prv_img.shape[0], prv_img.shape[1], 3), dtype='float32')
    hsv[...,1] = 255
    flows = []
    hsv_flows = []
    for i in range(n_flows):
        next_img = image_cube[:,:,step_size*i + start_idx + step_size]
        flow = cv2.calcOpticalFlowFarneback(prv_img,next_img, None, 0.5, 3, 15, 3, 5, 1.2, 0)
        flows.append(flow)

        mag, ang = cv2.cartToPolar(flow[...,0], flow[...,1])
        hsv[...,0] = ang*180/np.pi/2
        hsv[...,2] = mag # cv2.normalize(mag,None,0,255,cv2.NORM_MINMAX)
        rgb = cv2.cvtColor(hsv,cv2.COLOR_HSV2RGB)
        hsv_flows.append(rgb)

        prv_img = next_img

    xy_flow_cube = np.stack(flows, axis=3)
    hsv_flow_cube = np.stack(hsv_flows, axis=3)
    return xy_flow_cube, hsv_flow_cube


# Cell
def heatmap_fit(input_heatmap, draw_fit=False):
    """Returns (xrange, yrange) of the best fit to given heatmap"""

    frame = input_heatmap

    # setup initial location of window (top-left corner, plus x and y offsets)
    # X is left-to-right, Y is top-to-bottom
    x, y, w, h = 0, 0, frame.shape[1], frame.shape[0] # simply hardcoded the values
    track_window = (x, y, w, h)

    # Setup the termination criteria, either 10 iteration or move by atleast 1 pt
    term_crit = ( cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 30, 1 )

    # Define the target heatmap
    prob_image = frame

    # apply camshift to get the new location
    ret, track_window = cv2.CamShift(prob_image, track_window, term_crit)

    if draw_fit:
        import matplotlib.pyplot as plt
        # Draw it on image
        pts = cv2.boxPoints(ret)
        pts = np.int0(pts)
        img2 = cv2.polylines(frame.copy(),[pts],True, 1,2)
        plt.figure(figsize=(10,5))
        plt.imshow(img2)
        plt.show()

    max_x = max(p[0] for p in pts)
    min_x = max(0, min(p[0] for p in pts))
    max_y = max(p[1] for p in pts)
    min_y = min(p[1] for p in pts)

    return (min_x, max_x), (min_y, max_y)

# Cell
def trim_image(image, xrange, yrange):
    return image[yrange[0]:yrange[1], xrange[0]:xrange[1]]